{"ast":null,"code":"var _jsxFileName = \"/Users/gorubhambhani/Desktop/NEU/Fall'22/Final Project/Web Des/WebDes_FinalProject/dear-diary/src/components/Document/TextEditor.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useCallback, useState } from 'react';\nimport Quill from 'quill';\nimport \"quill/dist/quill.snow.css\"; //STYLESHEET THAT WE ARE GOING TO USE      \nimport { io } from \"socket.io-client\";\n//for documentid we have to use something from react-router\nimport { useParams } from 'react-router-dom';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SAVE_INTERVAL_MS = 2000;\n/*Give style to out toolbar*/\nconst TOOLBAR_OPTIONS = [[{\n  header: [1, 2, 3, 4, 5, 6, false]\n}], [{\n  font: []\n}], [{\n  list: \"ordered\"\n}, {\n  list: \"bullet\"\n}], [\"bold\", \"italic\", \"underline\"], [{\n  color: []\n}, {\n  background: []\n}], [{\n  script: \"sub\"\n}, {\n  script: \"super\"\n}], [{\n  align: []\n}], [\"image\", \"blockquote\", \"code-block\"], [\"clean\"]];\nexport default function TextEditor() {\n  _s();\n  const {\n    id: documentId\n  } = useParams();\n  //to access our socket from anywhere\n  const [socket, setSocket] = useState();\n  const [quill, setQuill] = useState();\n\n  //connect once\n  useEffect(() => {\n    const s = io(\"http://localhost:3001\");\n    setSocket(s);\n    console.log(\"connected to socket\");\n    return () => {\n      s.disconnect();\n    };\n  }, []);\n\n  //for detecting changes when quill changes\n  useEffect(() => {\n    //to make sure we have a socket and a quill\n    if (socket == null || quill == null) return;\n    const handler = (delta, oldDelta, source) => {\n      //source is gonna detect if user is gonna make changes or library has made changes\n      //to test if user has made the changes\n      if (source !== 'user') return;\n      //send the changes to user\n      //emit changes from client to a server\n      socket.emit(\"send-changes\", delta);\n      //delta is small subset of what is changing in document and then we are gonna send it to the server\n    };\n\n    quill.on('text-change', handler);\n\n    //we also need to pass the function we want to remove\n    return () => {\n      quill.off('text-change', handler);\n    };\n  }, [socket, quill]);\n\n  //handle to receive that event where we are telling it to broadcast that changes have been made\n  useEffect(() => {\n    if (socket == null || quill == null) return;\n    const handler = (delta, oldDelta, source) => {\n      quill.updateContents(delta); //make changes \n    };\n\n    socket.on('receive-changes', handler);\n    return () => {\n      socket.off('receive-changes', handler);\n    };\n  }, [socket, quill]);\n\n  //useeffect for save data and create new one\n  useEffect(() => {\n    if (socket == null || quill == null) return;\n    const interval = setInterval(() => {\n      socket.emit(\"save-document\", quill.getContents());\n    }, SAVE_INTERVAL_MS);\n    return () => {\n      clearInterval(interval);\n    };\n  }, [socket, quill]);\n\n  //when we are opening a different document in new tab, then when we are making changes in any of the document, the changes are being made in all of them irrespective of document id\n  //to avoid this situation we are creating a new useEffect\n  //everytime our socket or quill or  documentid changes, we will call this useEffect \n  useEffect(() => {\n    if (socket == null || quill == null) return;\n\n    //make sure to listen to that event\n    socket.once(\"load-document\", document => {\n      quill.setContents(document);\n      quill.enable();\n    });\n\n    //send this documentid to server so we can attach ourselves to the room for that document\n    //and if the document is saved, it is gonna send us to that document back \n    socket.emit('get-document', documentId);\n  }, [socket, quill, documentId]);\n\n  //to avoid re render\n  //re-render call\n  const wrapperRef = useCallback(wrapper => {\n    if (wrapper == null) return;\n\n    //we want to set it to empty string everytime we run it\n    wrapper.innerHTML = \"\";\n    const editor = document.createElement('div');\n    wrapper.append(editor); //saving the current state in this wrapperref\n    debugger;\n    const q = new Quill(editor, {\n      theme: \"snow\",\n      modules: {\n        toolbar: TOOLBAR_OPTIONS\n      }\n    });\n    setQuill(q);\n    //if I write something here and save it, it is going to re render the app - i.e will display the text editor again\n    //to avoid this - to clean up the previous toolbar and text editor, we have to wrap it up in one container\n    //sfxchvdgjchb\n    //inside useCallback we odn't have these return style cleanup\n    // return () => {\n    //     wrapperRef.innerHTML = \"\";\n    // }\n    q.disable();\n    q.setText(\"Loading...\");\n    setQuill(q);\n    //to disable the text cursor when the document is loading\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"container\",\n    ref: wrapperRef,\n    children: \"Text Editor\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 136,\n    columnNumber: 9\n  }, this);\n}\n_s(TextEditor, \"gbgidFagK+IuriZVWTIcbVbmJVI=\", false, function () {\n  return [useParams];\n});\n_c = TextEditor;\nvar _c;\n$RefreshReg$(_c, \"TextEditor\");","map":{"version":3,"names":["React","useEffect","useRef","useCallback","useState","Quill","io","useParams","SAVE_INTERVAL_MS","TOOLBAR_OPTIONS","header","font","list","color","background","script","align","TextEditor","id","documentId","socket","setSocket","quill","setQuill","s","console","log","disconnect","handler","delta","oldDelta","source","emit","on","off","updateContents","interval","setInterval","getContents","clearInterval","once","document","setContents","enable","wrapperRef","wrapper","innerHTML","editor","createElement","append","q","theme","modules","toolbar","disable","setText"],"sources":["/Users/gorubhambhani/Desktop/NEU/Fall'22/Final Project/Web Des/WebDes_FinalProject/dear-diary/src/components/Document/TextEditor.js"],"sourcesContent":["import React, { useEffect, useRef, useCallback, useState } from 'react'\nimport Quill from 'quill';\nimport \"quill/dist/quill.snow.css\";         //STYLESHEET THAT WE ARE GOING TO USE      \nimport { io } from \"socket.io-client\"\n//for documentid we have to use something from react-router\nimport { useParams } from 'react-router-dom'\n\n\nconst SAVE_INTERVAL_MS = 2000;\n/*Give style to out toolbar*/\nconst TOOLBAR_OPTIONS = [\n    [{ header: [1, 2, 3, 4, 5, 6, false] }],\n    [{ font: [] }],\n    [{ list: \"ordered\" }, { list: \"bullet\" }],\n    [\"bold\", \"italic\", \"underline\"],\n    [{ color: [] }, { background: [] }],\n    [{ script: \"sub\" }, { script: \"super\" }],\n    [{ align: [] }],\n    [\"image\", \"blockquote\", \"code-block\"],\n    [\"clean\"],\n]\n\nexport default function TextEditor() {\n    const { id: documentId } = useParams();\n    //to access our socket from anywhere\n    const [socket, setSocket] = useState();\n    const [quill, setQuill] = useState();\n\n    //connect once\n    useEffect(() => {\n        const s = io(\"http://localhost:3001\")\n        setSocket(s);\n        console.log(\"connected to socket\");\n\n        return () => {\n            s.disconnect()\n        }\n    }, [])\n\n    //for detecting changes when quill changes\n    useEffect(() => {\n        //to make sure we have a socket and a quill\n        if (socket == null || quill == null) return\n\n        const handler = (delta, oldDelta, source) => {\n            //source is gonna detect if user is gonna make changes or library has made changes\n            //to test if user has made the changes\n            if (source !== 'user') return\n            //send the changes to user\n            //emit changes from client to a server\n            socket.emit(\"send-changes\", delta);\n            //delta is small subset of what is changing in document and then we are gonna send it to the server\n        }\n        quill.on('text-change', handler);\n\n        //we also need to pass the function we want to remove\n        return () => {\n            quill.off('text-change', handler);\n        }\n    }, [socket, quill])\n\n    //handle to receive that event where we are telling it to broadcast that changes have been made\n    useEffect(() => {\n        if (socket == null || quill == null) return\n\n        const handler = (delta, oldDelta, source) => {\n            quill.updateContents(delta);     //make changes \n        }\n        socket.on('receive-changes', handler);\n\n        return () => {\n            socket.off('receive-changes', handler);\n        }\n    }, [socket, quill])\n\n    //useeffect for save data and create new one\n    useEffect(() => {\n        if (socket == null || quill == null) return;\n\n        const interval = setInterval(() => {\n            socket.emit(\"save-document\", quill.getContents());\n        }, SAVE_INTERVAL_MS)\n\n        return () => {\n            clearInterval(interval);\n        }\n    }, [socket, quill])\n\n    //when we are opening a different document in new tab, then when we are making changes in any of the document, the changes are being made in all of them irrespective of document id\n    //to avoid this situation we are creating a new useEffect\n    //everytime our socket or quill or  documentid changes, we will call this useEffect \n    useEffect(() => {\n        if (socket == null || quill == null) return;\n\n        //make sure to listen to that event\n        socket.once(\"load-document\", document => {\n            quill.setContents(document);\n            quill.enable();\n        })\n\n        //send this documentid to server so we can attach ourselves to the room for that document\n        //and if the document is saved, it is gonna send us to that document back \n        socket.emit('get-document', documentId);\n    }, [socket, quill, documentId])\n\n    //to avoid re render\n    //re-render call\n    const wrapperRef = useCallback((wrapper) => {\n        if (wrapper == null) return;\n\n        //we want to set it to empty string everytime we run it\n        wrapper.innerHTML = \"\";\n        const editor = document.createElement('div');\n        wrapper.append(editor);      //saving the current state in this wrapperref\n        debugger;\n        const q = new Quill(editor,\n            {\n                theme: \"snow\",\n                modules: { toolbar: TOOLBAR_OPTIONS},\n            });\n        setQuill(q);\n        //if I write something here and save it, it is going to re render the app - i.e will display the text editor again\n        //to avoid this - to clean up the previous toolbar and text editor, we have to wrap it up in one container\n        //sfxchvdgjchb\n        //inside useCallback we odn't have these return style cleanup\n        // return () => {\n        //     wrapperRef.innerHTML = \"\";\n        // }\n        q.disable();\n        q.setText(\"Loading...\");\n        setQuill(q);\n        //to disable the text cursor when the document is loading\n    }, [])\n\n    return (\n        <div className=\"container\" ref={wrapperRef}>\n            Text Editor\n        </div>\n    )\n}"],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,SAAS,EAAEC,MAAM,EAAEC,WAAW,EAAEC,QAAQ,QAAQ,OAAO;AACvE,OAAOC,KAAK,MAAM,OAAO;AACzB,OAAO,2BAA2B,CAAC,CAAS;AAC5C,SAASC,EAAE,QAAQ,kBAAkB;AACrC;AACA,SAASC,SAAS,QAAQ,kBAAkB;AAAA;AAG5C,MAAMC,gBAAgB,GAAG,IAAI;AAC7B;AACA,MAAMC,eAAe,GAAG,CACpB,CAAC;EAAEC,MAAM,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,KAAK;AAAE,CAAC,CAAC,EACvC,CAAC;EAAEC,IAAI,EAAE;AAAG,CAAC,CAAC,EACd,CAAC;EAAEC,IAAI,EAAE;AAAU,CAAC,EAAE;EAAEA,IAAI,EAAE;AAAS,CAAC,CAAC,EACzC,CAAC,MAAM,EAAE,QAAQ,EAAE,WAAW,CAAC,EAC/B,CAAC;EAAEC,KAAK,EAAE;AAAG,CAAC,EAAE;EAAEC,UAAU,EAAE;AAAG,CAAC,CAAC,EACnC,CAAC;EAAEC,MAAM,EAAE;AAAM,CAAC,EAAE;EAAEA,MAAM,EAAE;AAAQ,CAAC,CAAC,EACxC,CAAC;EAAEC,KAAK,EAAE;AAAG,CAAC,CAAC,EACf,CAAC,OAAO,EAAE,YAAY,EAAE,YAAY,CAAC,EACrC,CAAC,OAAO,CAAC,CACZ;AAED,eAAe,SAASC,UAAU,GAAG;EAAA;EACjC,MAAM;IAAEC,EAAE,EAAEC;EAAW,CAAC,GAAGZ,SAAS,EAAE;EACtC;EACA,MAAM,CAACa,MAAM,EAAEC,SAAS,CAAC,GAAGjB,QAAQ,EAAE;EACtC,MAAM,CAACkB,KAAK,EAAEC,QAAQ,CAAC,GAAGnB,QAAQ,EAAE;;EAEpC;EACAH,SAAS,CAAC,MAAM;IACZ,MAAMuB,CAAC,GAAGlB,EAAE,CAAC,uBAAuB,CAAC;IACrCe,SAAS,CAACG,CAAC,CAAC;IACZC,OAAO,CAACC,GAAG,CAAC,qBAAqB,CAAC;IAElC,OAAO,MAAM;MACTF,CAAC,CAACG,UAAU,EAAE;IAClB,CAAC;EACL,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA1B,SAAS,CAAC,MAAM;IACZ;IACA,IAAImB,MAAM,IAAI,IAAI,IAAIE,KAAK,IAAI,IAAI,EAAE;IAErC,MAAMM,OAAO,GAAG,CAACC,KAAK,EAAEC,QAAQ,EAAEC,MAAM,KAAK;MACzC;MACA;MACA,IAAIA,MAAM,KAAK,MAAM,EAAE;MACvB;MACA;MACAX,MAAM,CAACY,IAAI,CAAC,cAAc,EAAEH,KAAK,CAAC;MAClC;IACJ,CAAC;;IACDP,KAAK,CAACW,EAAE,CAAC,aAAa,EAAEL,OAAO,CAAC;;IAEhC;IACA,OAAO,MAAM;MACTN,KAAK,CAACY,GAAG,CAAC,aAAa,EAAEN,OAAO,CAAC;IACrC,CAAC;EACL,CAAC,EAAE,CAACR,MAAM,EAAEE,KAAK,CAAC,CAAC;;EAEnB;EACArB,SAAS,CAAC,MAAM;IACZ,IAAImB,MAAM,IAAI,IAAI,IAAIE,KAAK,IAAI,IAAI,EAAE;IAErC,MAAMM,OAAO,GAAG,CAACC,KAAK,EAAEC,QAAQ,EAAEC,MAAM,KAAK;MACzCT,KAAK,CAACa,cAAc,CAACN,KAAK,CAAC,CAAC,CAAK;IACrC,CAAC;;IACDT,MAAM,CAACa,EAAE,CAAC,iBAAiB,EAAEL,OAAO,CAAC;IAErC,OAAO,MAAM;MACTR,MAAM,CAACc,GAAG,CAAC,iBAAiB,EAAEN,OAAO,CAAC;IAC1C,CAAC;EACL,CAAC,EAAE,CAACR,MAAM,EAAEE,KAAK,CAAC,CAAC;;EAEnB;EACArB,SAAS,CAAC,MAAM;IACZ,IAAImB,MAAM,IAAI,IAAI,IAAIE,KAAK,IAAI,IAAI,EAAE;IAErC,MAAMc,QAAQ,GAAGC,WAAW,CAAC,MAAM;MAC/BjB,MAAM,CAACY,IAAI,CAAC,eAAe,EAAEV,KAAK,CAACgB,WAAW,EAAE,CAAC;IACrD,CAAC,EAAE9B,gBAAgB,CAAC;IAEpB,OAAO,MAAM;MACT+B,aAAa,CAACH,QAAQ,CAAC;IAC3B,CAAC;EACL,CAAC,EAAE,CAAChB,MAAM,EAAEE,KAAK,CAAC,CAAC;;EAEnB;EACA;EACA;EACArB,SAAS,CAAC,MAAM;IACZ,IAAImB,MAAM,IAAI,IAAI,IAAIE,KAAK,IAAI,IAAI,EAAE;;IAErC;IACAF,MAAM,CAACoB,IAAI,CAAC,eAAe,EAAEC,QAAQ,IAAI;MACrCnB,KAAK,CAACoB,WAAW,CAACD,QAAQ,CAAC;MAC3BnB,KAAK,CAACqB,MAAM,EAAE;IAClB,CAAC,CAAC;;IAEF;IACA;IACAvB,MAAM,CAACY,IAAI,CAAC,cAAc,EAAEb,UAAU,CAAC;EAC3C,CAAC,EAAE,CAACC,MAAM,EAAEE,KAAK,EAAEH,UAAU,CAAC,CAAC;;EAE/B;EACA;EACA,MAAMyB,UAAU,GAAGzC,WAAW,CAAE0C,OAAO,IAAK;IACxC,IAAIA,OAAO,IAAI,IAAI,EAAE;;IAErB;IACAA,OAAO,CAACC,SAAS,GAAG,EAAE;IACtB,MAAMC,MAAM,GAAGN,QAAQ,CAACO,aAAa,CAAC,KAAK,CAAC;IAC5CH,OAAO,CAACI,MAAM,CAACF,MAAM,CAAC,CAAC,CAAM;IAC7B;IACA,MAAMG,CAAC,GAAG,IAAI7C,KAAK,CAAC0C,MAAM,EACtB;MACII,KAAK,EAAE,MAAM;MACbC,OAAO,EAAE;QAAEC,OAAO,EAAE5C;MAAe;IACvC,CAAC,CAAC;IACNc,QAAQ,CAAC2B,CAAC,CAAC;IACX;IACA;IACA;IACA;IACA;IACA;IACA;IACAA,CAAC,CAACI,OAAO,EAAE;IACXJ,CAAC,CAACK,OAAO,CAAC,YAAY,CAAC;IACvBhC,QAAQ,CAAC2B,CAAC,CAAC;IACX;EACJ,CAAC,EAAE,EAAE,CAAC;EAEN,oBACI;IAAK,SAAS,EAAC,WAAW;IAAC,GAAG,EAAEN,UAAW;IAAA;EAAA;IAAA;IAAA;IAAA;EAAA,QAErC;AAEd;AAAC,GArHuB3B,UAAU;EAAA,QACHV,SAAS;AAAA;AAAA,KADhBU,UAAU;AAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}